# 빈 스코프

## 스코프 종류
- 싱글톤 : 기본 스코프 스프링 컨테이너의 시작과 종료의 유지가 가장 넓다.
  - 항상 같은 인스턴스의 스프링 빈 반환
- 프로토타입 : 스프링 컨테이너는 프로토타입 빈의 생성과 DI 까지만 관여 후 관리하지 않는 매우 짧은 스코프다 <br>
    -  항상 새로운 인스턴스를 생성해서 반환 후 관리 X , 이후 관리가 없기 떄문에 @PreDestroy 같은 종료 메서드 불가능.<br>
  
### 웹 관련 
- request : 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
- session 웹 세션이 생성되고 종료될 때까지 유지되는 스코프
- application: 웹의 서블릿 컨텍스와 같은 범위로 유지 되는 스코프
- webSocket : 웹 소켓과 동일한 생명주기를 가지는 스코프

# 빈을 검색할 때 (싱글톤 내부에서 프로토타입 찾기) 
## ObjectProvider
- 싱글톤 컨테이너 안에 프로토타입 빈을 넣었을 때 해당 빈은 프로토타입이 되지 않고 싱글톤이 유지된다.
  - 나는 싱글톤이 아니라 프로토타입이 필요한데 어떻게 해야할까?
  - 1차적으로 스프링 컨테이너 자체를 DI 하면 새로 생성 되지만 이건 전체를 가져오기에 코드도 좋지 못하고 단위 테스트도 불가능
- ObjectProvider<빈 이름> 으로 작성한다.
  - getObject()를 통해 필요한 로직을 찾는다.
  - 이렇게 외부에서 주입 받는게 아니라 내가 직접 찾는걸 DL(Dependency Lookup) 이라 한다.

## JSR-330 Provider
- implementation('javax.inject:javax.inject:1') 의존성 추가 필요
- private Provider<PrototypeBean> prototypeBeanProvider 형태로 작성
- 자바 표준이며 단위테스트나 mock 만들기 쉬움
- get() 하나로 기능이 단순하다, 별도 라이브러리 필요 , 스프링이 아니여도 사용가능.

# 프로토타입 빈을 언제 사용할까?
- 매번 사용할 때 DI가 완료된 새로운 객체가 필요할 때 사용하면 된다.
- 대부분 싱글톤으로 해결되서 사용하는 일은 드물다.

# Proxy
- Scope(value = "request",proxyMode = ScopedProxyMode.TARGET_CLASS) 형태로 작성
  - 사용하려는 컨트롤러와 서비스에선 그냥 생성자 주입으로 쓰고 ObjectProvider 를 사용하지 않아도 된다.
- CGLIB 를 통해 내 클래스를 상속받은 가짜 프록시 클래스를 만들어서 주입시켜준다.
- 그래서 평소엔 가짜를 집어넣었다가 실제 요청이 들어오면 진짜로 바꿔서 주입한다.
- 핵심은 실제 요청 전까지 지연처리 한다는 점.
- 무분별하게 사용하면 유지보수에 좋지 못하다.