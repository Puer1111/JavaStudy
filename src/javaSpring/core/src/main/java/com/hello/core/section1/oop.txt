-- SOLID 5원칙

S : SRP (Single Responsibility principle) 단일 책임 원칙
- 한 클래스는 하나의 책임만 가진다.
- 하나의 책임은 모호하다 -> 클 수도 작을 수도 있다. , 문맥과 상황에 따라 다르다 . 기준은 "변경" 이다 변경 시 파급 효과가 적으면 잘 한것.

O : OCP (Open Closed Principle) 개방 - 폐쇄 원칙

소프트웨어 확장에는 열려있어야 하나 , 변경에는 닫혀 있어야 한다.
기존 코드는 바뀌지 않으면서 , 새로운 확장은 가능해아 한다. ex ) 다형성 - 차의 종류가 늘어난다해서 기존 코드가 틀어지진 않음.

※문제점 : 기존 코드 변경 없이 구현 객체를 바꿀 수가 없다.
    MemberService 가 구현 클래스를 선택
    - MemberRepository m = new MemoryMemberRepository();            => DIP 위반
    - MemberRepository m = new JDBCMemberRepository();              => DIP 위반
※해결법 객체를 생성하고 , 연관관계를 맺어주는 별도의 조립 , 설정자가 필요하다. --> Spring 의 Autowired? IOC 에 의해 관리 됨.

L : LSP (Liskov substitution principle) 리스코프 치환 원칙
- 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지킨다는 것, 다형성을 지원하기 위한 원칙 인터페이스를 구현한 구현체는 믿고 사용 하려면 이 원칙이 필요하다.

I : ISP (Interface Segregation Principle) 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 -> 운전 인터페이스 , 정비 인터페이스 분리
- 사용자 인터페이스 -> 운전자 클라이언트 , 정비사 클라이언트 분리
- 인터페이스가 명확해지고 대체 가능성 높아짐.

D: DIP (Dependency Inversion Principle) 의존관계 역전 원칙
- 프로그래머는 추상화에 의존해야지 구체화에 의존하면 안된다.
- 구현 클래스에 의존하지 말고 Interface 에 의존하라.
- 그래야 변경 시 유연하게 대처 가능하다.

--------------------------------------------------------------------------------------------------------------------------------

-- 정리

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성으로는 OCP , DIP 를 지킬 수 없다.